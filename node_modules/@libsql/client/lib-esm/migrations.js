const SCHEMA_MIGRATION_SLEEP_TIME_IN_MS = 1000;
const SCHEMA_MIGRATION_MAX_RETRIES = 30;
async function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
async function isMigrationJobFinished({ authToken, baseUrl, jobId, }) {
    const url = normalizeURLScheme(baseUrl + `/v1/jobs/${jobId}`);
    const result = await fetch(url, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${authToken}`,
        },
    });
    const json = (await result.json());
    const job = json;
    if (result.status !== 200) {
        throw new Error(`Unexpected status code while fetching job status for migration with id ${jobId}: ${result.status}`);
    }
    if (job.status == "RunFailure") {
        throw new Error("Migration job failed");
    }
    return job.status == "RunSuccess";
}
function normalizeURLScheme(url) {
    if (url.startsWith("ws://")) {
        return url.replace("ws://", "http://");
    }
    if (url.startsWith("wss://")) {
        return url.replace("wss://", "https://");
    }
    return url;
}
export async function getIsSchemaDatabase({ authToken, baseUrl, }) {
    let responseStatusCode;
    try {
        if (baseUrl.startsWith("http://127.0.0.1")) {
            return false;
        }
        const url = normalizeURLScheme(baseUrl + "/v1/jobs");
        const result = await fetch(url, {
            method: "GET",
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
        });
        if (result.status === 404 || result.status === 500) {
            return false;
        }
        const json = (await result.json());
        const isChildDatabase = result.status === 400 && json.error === "Invalid namespace";
        return !isChildDatabase;
    }
    catch (e) {
        console.error([
            `There has been an error while retrieving the database type.`,
            `Debug information:`,
            `- URL: ${baseUrl}`,
            `- Response Status Code: ${responseStatusCode ? responseStatusCode : "N/A"}`,
        ].join("\n"));
        throw e;
    }
}
async function getLastMigrationJob({ authToken, baseUrl, }) {
    const url = normalizeURLScheme(baseUrl + "/v1/jobs");
    const result = await fetch(url, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${authToken}`,
        },
    });
    if (result.status !== 200) {
        throw new Error("Unexpected status code while fetching migration jobs: " +
            result.status);
    }
    const json = (await result.json());
    if (!json.migrations || json.migrations.length === 0) {
        throw new Error("No migrations found");
    }
    const migrations = json.migrations || [];
    let lastJob;
    for (const migration of migrations) {
        if (migration.job_id > (lastJob?.job_id || 0)) {
            lastJob = migration;
        }
    }
    if (!lastJob) {
        throw new Error("No migration job found");
    }
    if (lastJob?.status === "RunFailure") {
        throw new Error("Last migration job failed");
    }
    return lastJob;
}
export async function waitForLastMigrationJobToFinish({ authToken, baseUrl, }) {
    const lastMigrationJob = await getLastMigrationJob({
        authToken: authToken,
        baseUrl,
    });
    if (lastMigrationJob.status !== "RunSuccess") {
        let i = 0;
        while (i < SCHEMA_MIGRATION_MAX_RETRIES) {
            i++;
            const isLastMigrationJobFinished = await isMigrationJobFinished({
                authToken: authToken,
                baseUrl,
                jobId: lastMigrationJob.job_id,
            });
            if (isLastMigrationJobFinished) {
                break;
            }
            await sleep(SCHEMA_MIGRATION_SLEEP_TIME_IN_MS);
        }
    }
}
